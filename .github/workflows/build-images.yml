name: Build Hardened Images

on:
  push:
    branches: [ main ]
    paths:
      - 'images/**'
      - 'scripts/build-images.sh'
      - '.github/workflows/build-images.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'images/**'
      - 'scripts/build-images.sh'
      - '.github/workflows/build-images.yml'
  workflow_dispatch:
    inputs:
      push_images:
        description: 'Push images to registry'
        required: false
        default: false
        type: boolean
      filter:
        description: 'Filter images to build (regex pattern)'
        required: false
        default: ''
      version:
        description: 'Filter images by version (e.g., 1.33.3, v1.34.0)'
        required: false
        default: ''
      rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: docker.io
  ORGANIZATION: titaniumlabs

jobs:
  discover-images:
    name: Discover Images to Build
    runs-on: ubuntu-latest
    outputs:
      base-images: ${{ steps.discovery.outputs.base-images }}
      app-images: ${{ steps.discovery.outputs.app-images }}
      all-images: ${{ steps.discovery.outputs.all-images }}
      has-images: ${{ steps.discovery.outputs.has-images }}
      image-matrix: ${{ steps.discovery.outputs.image-matrix }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Need full history to detect changes

      - name: Discover images
        id: discovery
        run: |
          # Get changed files for push/pull_request events
          CHANGED_FILES=()
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # For push events, compare with previous commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git diff --name-only $(git rev-list --max-parents=0 HEAD) HEAD)
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, get files changed in the PR
            git fetch origin ${{ github.base_ref }}
            CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # For manual runs, build all images (unless filtered)
            echo "Manual run - will build all images unless filtered"
          fi

          echo "Changed files detected:"
          echo "$CHANGED_FILES"

          # Function to check if an image directory has changes
          has_changes() {
            local image_dir="$1"

            # For workflow_dispatch, always return true unless filtered
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              return 0
            fi

            # Check if any changed file is within this image directory
            while IFS= read -r changed_file; do
              if [[ "$changed_file" == "$image_dir"/* ]]; then
                echo "Found change in $image_dir: $changed_file"
                return 0
              fi
            done <<< "$CHANGED_FILES"
            return 1
          }

          # Discover base images
          BASE_IMAGES=()
          while IFS= read -r -d '' dockerfile; do
            image_dir=$(dirname "$dockerfile")
            relative_path=$(realpath --relative-to="images" "$image_dir")

            if [[ "$relative_path" =~ ^base_images/([^/]+)/([^/]+)$ ]]; then
              os="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              tag="$ORGANIZATION/$os:$version"

              # Only add if there are changes in this directory
              if has_changes "$image_dir"; then
                BASE_IMAGES+=("$image_dir:$tag")
                echo "Will build changed image: $tag"
              else
                echo "Skipping unchanged image: $tag"
              fi
            fi
          done < <(find images/base_images -name "Dockerfile" -print0 2>/dev/null || true)

          # Discover app images
          APP_IMAGES=()
          while IFS= read -r -d '' dockerfile; do
            image_dir=$(dirname "$dockerfile")
            relative_path=$(realpath --relative-to="images" "$image_dir")

            if [[ "$relative_path" =~ ^base_images/ ]]; then
              continue
            fi

            if [[ "$relative_path" =~ ^([^/]+)/([^/]+)$ ]]; then
              app="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              tag="$ORGANIZATION/$app:$version"

              # Only add if there are changes in this directory
              if has_changes "$image_dir"; then
                APP_IMAGES+=("$image_dir:$tag")
                echo "Will build changed image: $tag"
              else
                echo "Skipping unchanged image: $tag"
              fi
            fi
          done < <(find images -name "Dockerfile" -not -path "*/base_images/*" -print0 2>/dev/null || true)

          # Combine all images
          ALL_IMAGES=("${BASE_IMAGES[@]}" "${APP_IMAGES[@]}")

          # Apply filters if specified
          if [[ -n "${{ github.event.inputs.filter }}" || -n "${{ github.event.inputs.version }}" ]]; then
            FILTERED_IMAGES=()
            for image_spec in "${ALL_IMAGES[@]}"; do
              local matches_filter=true
              local matches_version=true

              # Check name filter
              if [[ -n "${{ github.event.inputs.filter }}" ]]; then
                if [[ ! "$image_spec" =~ "${{ github.event.inputs.filter }}" ]]; then
                  matches_filter=false
                fi
              fi

              # Check version filter
              if [[ -n "${{ github.event.inputs.version }}" ]]; then
                tag_part="${image_spec#*:}"
                if [[ ! "$tag_part" =~ ":.*${{ github.event.inputs.version }}" ]]; then
                  matches_version=false
                fi
              fi

              # Include only if both filters match
              if [[ $matches_filter == true && $matches_version == true ]]; then
                FILTERED_IMAGES+=("$image_spec")
              fi
            done
            ALL_IMAGES=("${FILTERED_IMAGES[@]}")

            echo "Applied filters:"
            [[ -n "${{ github.event.inputs.filter }}" ]] && echo "  Name filter: ${{ github.event.inputs.filter }}"
            [[ -n "${{ github.event.inputs.version }}" ]] && echo "  Version filter: ${{ github.event.inputs.version }}"
          fi

          # Convert to JSON for GitHub Actions
          BASE_IMAGES_JSON=$(if [ ${#BASE_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${BASE_IMAGES[@]}" | jq -R . | jq -s -c .; fi)
          APP_IMAGES_JSON=$(if [ ${#APP_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${APP_IMAGES[@]}" | jq -R . | jq -s -c .; fi)
          ALL_IMAGES_JSON=$(if [ ${#ALL_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${ALL_IMAGES[@]}" | jq -R . | jq -s -c .; fi)

          # Create matrix for parallel builds
          MATRIX_JSON=$(if [ ${#ALL_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${ALL_IMAGES[@]}" | jq -R 'split(":") | {path: .[0], tag: (.[1:] | join(":")), name: (.[1:] | join(":") | gsub("[/:]"; "-")), image: (.[1:] | join(":") | split(":")[0]), version: (.[1:] | join(":") | split(":")[1])}' | jq -s -c .; fi)

          echo "base-images=$BASE_IMAGES_JSON" >> $GITHUB_OUTPUT
          echo "app-images=$APP_IMAGES_JSON" >> $GITHUB_OUTPUT
          echo "all-images=$ALL_IMAGES_JSON" >> $GITHUB_OUTPUT
          echo "has-images=$(if [ ${#ALL_IMAGES[@]} -gt 0 ]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
          echo "image-matrix={\"include\":$MATRIX_JSON}" >> $GITHUB_OUTPUT

          if [ ${#ALL_IMAGES[@]} -eq 0 ]; then
            echo "No image changes detected in this commit"
          else
            echo "Discovered ${#ALL_IMAGES[@]} changed images to build:"
            for img in "${ALL_IMAGES[@]}"; do
              echo "  - $(echo $img | cut -d: -f2-)"
            done
          fi

  dockerfile-lint:
    name: Dockerfile Linting
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          recursive: true
          dockerfile: "images/**/Dockerfile"
          format: sarif
          output-file: hadolint-results.sarif
          no-fail: true
          ignore: DL3008,DL3009

      - name: Upload Hadolint results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: hadolint-results.sarif
          category: hadolint

  build-images:
    name: Build Images
    runs-on: ubuntu-latest
    needs: [discover-images, dockerfile-lint]
    if: |
      always() &&
      needs.discover-images.outputs.has-images == 'true' &&
      (needs.dockerfile-lint.result == 'success' || needs.dockerfile-lint.result == 'skipped')

    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event.inputs.push_images == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Make build script executable
        run: chmod +x scripts/build-images.sh

      - name: Build images using build script
        run: |
          # Parse filters from discovery or manual inputs
          FILTER_ARG=""
          VERSION_ARG=""

          # Handle manual filter input
          if [[ -n "${{ github.event.inputs.filter }}" ]]; then
            FILTER_ARG="--filter '${{ github.event.inputs.filter }}'"
          elif [[ -n "${{ needs.discover-images.outputs.all-images }}" ]]; then
            # Extract image names from discovered images (remove organization prefix)
            IMAGES=$(echo '${{ needs.discover-images.outputs.all-images }}' | jq -r '.[] | split(":")[1] | split("/")[1] | split(":")[0]' | tr '\n' '|' | sed 's/|$//')
            if [[ -n "$IMAGES" ]]; then
              FILTER_ARG="--filter '$IMAGES'"
            fi
          fi
          
          # Handle version filter input
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION_ARG="--version '${{ github.event.inputs.version }}'"
          fi

          # Build images with appropriate flags
          BUILD_CMD="./scripts/build-images.sh"
          if [[ "${{ github.event.inputs.rebuild }}" == "true" ]]; then
            BUILD_CMD="$BUILD_CMD --rebuild"
          fi
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.event.inputs.push_images }}" == "true" ]]; then
            BUILD_CMD="$BUILD_CMD --push"
          fi
          if [[ -n "$FILTER_ARG" ]]; then
            BUILD_CMD="$BUILD_CMD $FILTER_ARG"
          fi
          if [[ -n "$VERSION_ARG" ]]; then
            BUILD_CMD="$BUILD_CMD $VERSION_ARG"
          fi

          echo "Running: $BUILD_CMD"
          eval $BUILD_CMD

  security-summary:
    name: Security Summary
    runs-on: ubuntu-latest
    needs: build-images
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event.inputs.push_images == 'true'

    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: security-reports

      - name: Generate Security Summary
        run: |
          echo "# Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build and Security Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "| Image | Build | Trivy | Grype | SBOM |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|-------|-------|------|" >> $GITHUB_STEP_SUMMARY

          # Parse results from artifacts
          for report_dir in security-reports/trivy-report-*; do
            if [ -d "$report_dir" ]; then
              image_name=$(basename "$report_dir" | sed 's/trivy-report-//')
              echo "| $image_name | OK | OK | OK | OK |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Security reports and SBOMs available as workflow artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- SARIF results uploaded to GitHub Security tab" >> $GITHUB_STEP_SUMMARY

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Count artifacts
            let sbomCount = 0;
            let trivyCount = 0;

            try {
              const dirs = fs.readdirSync('security-reports');
              sbomCount = dirs.filter(d => d.startsWith('sbom-')).length;
              trivyCount = dirs.filter(d => d.startsWith('trivy-report-')).length;
            } catch (e) {
              console.log('Could not read security-reports directory');
            }

            const comment = `## Build & Security Summary

            ### Workflow completed successfully

            | Check | Status | Details |
            |-------|--------|---------|
            | Dockerfile Linting | PASS | Hadolint best practices check |
            | Image Build | PASS | ${trivyCount} images built |
            | Vulnerability Scan | PASS | Trivy & Grype scanning completed |
            | SBOM Generation | PASS | ${sbomCount} SBOMs generated |

            ### Results Available\
            - [GitHub Security Tab](https://github.com/${{ github.repository }}/security/code-scanning)
            - [Workflow Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})

            Images will be automatically pushed to Docker Hub when this PR is merged to main.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  discover-readme-files:
    name: Discover README Files
    runs-on: ubuntu-latest
    if: success() && (github.event_name == 'push' && github.ref == 'refs/heads/main')
    outputs:
      readme-matrix: ${{ steps.discovery.outputs.readme-matrix }}
      has-readmes: ${{ steps.discovery.outputs.has-readmes }}
      changed-readmes: ${{ steps.discovery.outputs.changed-readmes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover README files
        id: discovery
        run: |
          # Get list of changed files if this is a push event
          CHANGED_FILES=()
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Get changed files from the push
            git fetch origin ${{ github.event.before }} --depth=50 2>/dev/null || git fetch --unshallow
            mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.sha }} 2>/dev/null || echo "")
            echo "Changed files in this push:"
            printf '%s\n' "${CHANGED_FILES[@]}"
          fi

          # Function to check if a file was changed
          file_was_changed() {
            local file="$1"
            if [[ "${{ github.event_name }}" != "push" ]]; then
              # For workflow_dispatch, process all README files
              return 0
            fi

            for changed_file in "${CHANGED_FILES[@]}"; do
              if [[ "$changed_file" == "$file" ]]; then
                return 0
              fi
            done
            return 1
          }

          # Array to store README file mappings
          README_FILES=()
          CHANGED_READMES=()

          # Find base image README files
          find images/base_images -name "README.md" | while read -r readme_file; do
            readme_dir=$(dirname "$readme_file")
            relative_path=$(python3 -c "import os; print(os.path.relpath('$readme_dir', 'images'))")

            if [[ "$relative_path" == base_images/* ]]; then
              # Base image README (e.g., base_images/rockylinux/README.md)
              os=$(echo "$relative_path" | sed 's|^base_images/||')
              repository="$ORGANIZATION/$os"

              echo "Found base image README: $readme_file -> $repository" >&2

              # Only include if file was changed or this is workflow_dispatch
              if file_was_changed "$readme_file"; then
                echo "README file was changed: $readme_file" >&2
                echo "$readme_file|$repository"
              else
                echo "README file unchanged, skipping: $readme_file" >&2
              fi
            fi
          done > readme_mappings.txt

          # Find app image README files
          find images -name "README.md" -not -path "*/base_images/*" | while read -r readme_file; do
            readme_dir=$(dirname "$readme_file")
            relative_path=$(python3 -c "import os; print(os.path.relpath('$readme_dir', 'images'))")

            # Extract app name from path (first directory component)
            app=$(echo "$relative_path" | cut -d'/' -f1)
            if [[ -n "$app" ]]; then
              repository="$ORGANIZATION/$app"

              echo "Found app image README: $readme_file -> $repository" >&2

              # Only include if file was changed or this is workflow_dispatch
              if file_was_changed "$readme_file"; then
                echo "README file was changed: $readme_file" >&2
                echo "$readme_file|$repository"
              else
                echo "README file unchanged, skipping: $readme_file" >&2
              fi
            fi
          done >> readme_mappings.txt

          # Convert to JSON matrix
          if [[ -s readme_mappings.txt ]]; then
            MATRIX_JSON=$(cat readme_mappings.txt | jq -R 'split("|") | {readme_file: .[0], repository: .[1], name: (.[1] | gsub("[/:]"; "-"))}' | jq -s -c .)
            echo "readme-matrix={\"include\":$MATRIX_JSON}" >> $GITHUB_OUTPUT
            echo "has-readmes=true" >> $GITHUB_OUTPUT
            echo "changed-readmes=true" >> $GITHUB_OUTPUT
            echo "Found $(wc -l < readme_mappings.txt) changed README files to update"
          else
            echo "readme-matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "has-readmes=false" >> $GITHUB_OUTPUT
            echo "changed-readmes=false" >> $GITHUB_OUTPUT
            echo "No changed README files found"
          fi

  update-dockerhub-readme:
    name: Update README - ${{ matrix.name }}
    runs-on: ubuntu-latest
    needs: discover-readme-files
    if: needs.discover-readme-files.outputs.changed-readmes == 'true'

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.discover-readme-files.outputs.readme-matrix) }}

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Docker Hub Description
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}
          repository: ${{ matrix.repository }}
          readme-filepath: ${{ matrix.readme_file }}
          enable-url-completion: true
