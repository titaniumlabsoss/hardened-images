name: Build Hardened Images

on:
  push:
    branches: [ main ]
    paths:
      - 'images/**'
      - 'scripts/build-images.sh'
      - '.github/workflows/build-images.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'images/**'
      - 'scripts/build-images.sh'
      - '.github/workflows/build-images.yml'
  workflow_dispatch:
    inputs:
      push_images:
        description: 'Push images to registry'
        required: false
        default: false
        type: boolean
      filter:
        description: 'Filter images to build (regex pattern)'
        required: false
        default: ''
      rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: docker.io
  ORGANIZATION: titaniumlabs

jobs:
  discover-images:
    name: Discover Images to Build
    runs-on: ubuntu-latest
    outputs:
      base-images: ${{ steps.discovery.outputs.base-images }}
      app-images: ${{ steps.discovery.outputs.app-images }}
      all-images: ${{ steps.discovery.outputs.all-images }}
      has-images: ${{ steps.discovery.outputs.has-images }}
      image-matrix: ${{ steps.discovery.outputs.image-matrix }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover images
        id: discovery
        run: |
          # Discover base images
          BASE_IMAGES=()
          while IFS= read -r -d '' dockerfile; do
            image_dir=$(dirname "$dockerfile")
            relative_path=$(realpath --relative-to="images" "$image_dir")

            if [[ "$relative_path" =~ ^base_images/([^/]+)/([^/]+)$ ]]; then
              os="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              tag="$ORGANIZATION/$os:$version"
              BASE_IMAGES+=("$image_dir:$tag")
            fi
          done < <(find images/base_images -name "Dockerfile" -print0 2>/dev/null || true)

          # Discover app images
          APP_IMAGES=()
          while IFS= read -r -d '' dockerfile; do
            image_dir=$(dirname "$dockerfile")
            relative_path=$(realpath --relative-to="images" "$image_dir")

            if [[ "$relative_path" =~ ^base_images/ ]]; then
              continue
            fi

            if [[ "$relative_path" =~ ^([^/]+)/([^/]+)/([^/]+)$ ]]; then
              app="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              os="${BASH_REMATCH[3]}"

              if [[ "$os" == "alpine" ]]; then
                tag="$ORGANIZATION/$app:$version-minimal"
              else
                tag="$ORGANIZATION/$app:$version"
              fi

              APP_IMAGES+=("$image_dir:$tag")
            fi
          done < <(find images -name "Dockerfile" -not -path "*/base_images/*" -print0 2>/dev/null || true)

          # Combine all images
          ALL_IMAGES=("${BASE_IMAGES[@]}" "${APP_IMAGES[@]}")

          # Apply filter if specified
          if [[ -n "${{ github.event.inputs.filter }}" ]]; then
            FILTERED_IMAGES=()
            for image_spec in "${ALL_IMAGES[@]}"; do
              if [[ "$image_spec" =~ "${{ github.event.inputs.filter }}" ]]; then
                FILTERED_IMAGES+=("$image_spec")
              fi
            done
            ALL_IMAGES=("${FILTERED_IMAGES[@]}")
          fi

          # Convert to JSON for GitHub Actions
          BASE_IMAGES_JSON=$(if [ ${#BASE_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${BASE_IMAGES[@]}" | jq -R . | jq -s -c .; fi)
          APP_IMAGES_JSON=$(if [ ${#APP_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${APP_IMAGES[@]}" | jq -R . | jq -s -c .; fi)
          ALL_IMAGES_JSON=$(if [ ${#ALL_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${ALL_IMAGES[@]}" | jq -R . | jq -s -c .; fi)

          # Create matrix for parallel builds
          MATRIX_JSON=$(if [ ${#ALL_IMAGES[@]} -eq 0 ]; then echo '[]'; else printf '%s\n' "${ALL_IMAGES[@]}" | jq -R 'split(":") | {path: .[0], tag: (.[1:] | join(":")), name: (.[1:] | join(":") | gsub("[/:]"; "-")), image: .[1], version: .[2], is_minimal: (.[2] | contains("-minimal"))}' | jq -s -c .; fi)

          echo "base-images=$BASE_IMAGES_JSON" >> $GITHUB_OUTPUT
          echo "app-images=$APP_IMAGES_JSON" >> $GITHUB_OUTPUT
          echo "all-images=$ALL_IMAGES_JSON" >> $GITHUB_OUTPUT
          echo "has-images=$(if [ ${#ALL_IMAGES[@]} -gt 0 ]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
          echo "image-matrix={\"include\":$MATRIX_JSON}" >> $GITHUB_OUTPUT

          echo "Discovered ${#ALL_IMAGES[@]} images to build"

  dockerfile-lint:
    name: Dockerfile Linting
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
      security-events: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Hadolint
        uses: hadolint/hadolint-action@v3.1.0
        with:
          recursive: true
          dockerfile: "images/**/Dockerfile"
          format: sarif
          output-file: hadolint-results.sarif
          no-fail: true
          ignore: DL3008,DL3009

      - name: Upload Hadolint results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: hadolint-results.sarif
          category: hadolint

  build-images:
    name: Build - ${{ matrix.name }}
    runs-on: ubuntu-latest
    needs: [discover-images, dockerfile-lint]
    if: |
      always() &&
      needs.discover-images.outputs.has-images == 'true' &&
      (needs.dockerfile-lint.result == 'success' || needs.dockerfile-lint.result == 'skipped')

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.discover-images.outputs.image-matrix) }}

    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event.inputs.push_images == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ matrix.image }}
          tags: |
            type=raw,value=${{ matrix.version }}
            type=raw,value=${{ matrix.version }}-{{date 'YYYYMMDD'}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build image for scanning (amd64 only)
        id: build-scan
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.path }}
          platforms: linux/amd64
          tags: ${{ matrix.image }}:scan
          labels: ${{ steps.meta.outputs.labels }}
          push: false
          load: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ github.event.inputs.rebuild == 'true' }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ matrix.image }}:scan
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
        continue-on-error: true

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
          category: trivy-${{ matrix.name }}

      - name: Run Grype vulnerability scanner
        uses: anchore/scan-action@v4
        id: grype
        with:
          image: ${{ matrix.image }}:scan
          fail-build: false
          severity-cutoff: critical
          output-format: sarif
        continue-on-error: true

      - name: Upload Grype results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: ${{ steps.grype.outputs.sarif }}
          category: grype-${{ matrix.name }}

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          image: ${{ matrix.image }}:scan
          format: spdx-json
          output-file: sbom-${{ matrix.name }}.spdx.json

      - name: Upload SBOM as artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ matrix.name }}
          path: sbom-${{ matrix.name }}.spdx.json
          retention-days: 30

      - name: Generate Trivy JSON report
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ matrix.image }}:scan
          format: 'json'
          output: 'trivy-report.json'
          severity: 'CRITICAL,HIGH,MEDIUM,LOW'

      - name: Upload Trivy JSON report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report-${{ matrix.name }}
          path: trivy-report.json
          retention-days: 30

      - name: Build and push multi-platform image
        if: success() && (github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event.inputs.push_images == 'true')
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.path }}
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          push: true
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ github.event.inputs.rebuild == 'true' }}

      - name: Build multi-platform image (PR - no push)
        if: success() && github.event_name == 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.path }}
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          push: false
          cache-from: type=gha
          cache-to: type=gha,mode=max
          no-cache: ${{ github.event.inputs.rebuild == 'true' }}

  security-summary:
    name: Security Summary
    runs-on: ubuntu-latest
    needs: build-images
    if: always()

    permissions:
      contents: read
      issues: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: security-reports

      - name: Generate Security Summary
        run: |
          echo "# Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Build and Security Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "| Image | Build | Trivy | Grype | SBOM |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-------|-------|-------|------|" >> $GITHUB_STEP_SUMMARY

          # Parse results from artifacts
          for report_dir in security-reports/trivy-report-*; do
            if [ -d "$report_dir" ]; then
              image_name=$(basename "$report_dir" | sed 's/trivy-report-//')
              echo "| $image_name | OK | OK | OK | OK |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- Security reports and SBOMs available as workflow artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- SARIF results uploaded to GitHub Security tab" >> $GITHUB_STEP_SUMMARY

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
  
            // Count artifacts
            let sbomCount = 0;
            let trivyCount = 0;
  
            try {
              const dirs = fs.readdirSync('security-reports');
              sbomCount = dirs.filter(d => d.startsWith('sbom-')).length;
              trivyCount = dirs.filter(d => d.startsWith('trivy-report-')).length;
            } catch (e) {
              console.log('Could not read security-reports directory');
            }
  
            const comment = `## Build & Security Summary
  
            ### Workflow completed successfully
  
            | Check | Status | Details |
            |-------|--------|---------|
            | Dockerfile Linting | PASS | Hadolint best practices check |
            | Image Build | PASS | ${trivyCount} images built |
            | Vulnerability Scan | PASS | Trivy & Grype scanning completed |
            | SBOM Generation | PASS | ${sbomCount} SBOMs generated |
  
            ### Results Available
            - [GitHub Security Tab](https://github.com/${{ github.repository }}/security/code-scanning)
            - [Workflow Artifacts](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
  
            Images will be automatically pushed to Docker Hub when this PR is merged to main.`;
  
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  discover-readme-files:
    name: Discover README Files
    runs-on: ubuntu-latest
    needs: discover-images
    if: |
      always() &&
      needs.discover-images.outputs.has-images == 'true' &&
      (needs.dockerfile-lint.result == 'success' || needs.dockerfile-lint.result == 'skipped')
    outputs:
      readme-matrix: ${{ steps.discovery.outputs.readme-matrix }}
      has-readmes: ${{ steps.discovery.outputs.has-readmes }}
      changed-readmes: ${{ steps.discovery.outputs.changed-readmes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover README files
        id: discovery
        run: |
          # Get list of changed files if this is a push event
          CHANGED_FILES=()
          if [[ "${{ github.event_name }}" == "push" ]]; then
            # Get changed files from the push
            git fetch origin ${{ github.event.before }} --depth=50 2>/dev/null || git fetch --unshallow
            mapfile -t CHANGED_FILES < <(git diff --name-only ${{ github.event.before }} ${{ github.sha }} 2>/dev/null || echo "")
            echo "Changed files in this push:"
            printf '%s\n' "${CHANGED_FILES[@]}"
          fi

          # Function to check if a file was changed
          file_was_changed() {
            local file="$1"
            if [[ "${{ github.event_name }}" != "push" ]]; then
              # For workflow_dispatch, process all README files
              return 0
            fi

            for changed_file in "${CHANGED_FILES[@]}"; do
              if [[ "$changed_file" == "$file" ]]; then
                return 0
              fi
            done
            return 1
          }

          # Array to store README file mappings
          README_FILES=()
          CHANGED_READMES=()

          # Find base image README files
          find images/base_images -name "README.md" | while read -r readme_file; do
            readme_dir=$(dirname "$readme_file")
            relative_path=$(python3 -c "import os; print(os.path.relpath('$readme_dir', 'images'))")

            if [[ "$relative_path" == base_images/* ]]; then
              # Base image README (e.g., base_images/rockylinux/README.md)
              os=$(echo "$relative_path" | sed 's|^base_images/||')
              repository="$ORGANIZATION/$os"

              echo "Found base image README: $readme_file -> $repository" >&2

              # Only include if file was changed or this is workflow_dispatch
              if file_was_changed "$readme_file"; then
                echo "README file was changed: $readme_file" >&2
                echo "$readme_file|$repository"
              else
                echo "README file unchanged, skipping: $readme_file" >&2
              fi
            fi
          done > readme_mappings.txt

          # Find app image README files
          find images -name "README.md" -not -path "*/base_images/*" | while read -r readme_file; do
            readme_dir=$(dirname "$readme_file")
            relative_path=$(python3 -c "import os; print(os.path.relpath('$readme_dir', 'images'))")

            # Extract app name from path (first directory component)
            app=$(echo "$relative_path" | cut -d'/' -f1)
            if [[ -n "$app" ]]; then
              repository="$ORGANIZATION/$app"

              echo "Found app image README: $readme_file -> $repository" >&2

              # Only include if file was changed or this is workflow_dispatch
              if file_was_changed "$readme_file"; then
                echo "README file was changed: $readme_file" >&2
                echo "$readme_file|$repository"
              else
                echo "README file unchanged, skipping: $readme_file" >&2
              fi
            fi
          done >> readme_mappings.txt

          # Convert to JSON matrix
          if [[ -s readme_mappings.txt ]]; then
            MATRIX_JSON=$(cat readme_mappings.txt | jq -R 'split("|") | {readme_file: .[0], repository: .[1], name: (.[1] | gsub("[/:]"; "-"))}' | jq -s -c .)
            echo "readme-matrix={\"include\":$MATRIX_JSON}" >> $GITHUB_OUTPUT
            echo "has-readmes=true" >> $GITHUB_OUTPUT
            echo "changed-readmes=true" >> $GITHUB_OUTPUT
            echo "Found $(wc -l < readme_mappings.txt) changed README files to update"
          else
            echo "readme-matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "has-readmes=false" >> $GITHUB_OUTPUT
            echo "changed-readmes=false" >> $GITHUB_OUTPUT
            echo "No changed README files found"
          fi

  update-dockerhub-readme:
    name: Update README - ${{ matrix.name }}
    runs-on: ubuntu-latest
    needs: discover-readme-files
    if: needs.discover-readme-files.outputs.changed-readmes == 'true'

    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.discover-readme-files.outputs.readme-matrix) }}

    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Docker Hub Description
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_TOKEN }}
          repository: ${{ matrix.repository }}
          readme-filepath: ${{ matrix.readme_file }}
          enable-url-completion: true
